#include "bgfx/defines.h"
#include "bx/bx.h"
#include <bgfx/bgfx.h>
#include <GLFW/glfw3.h>
#include <engine/imgui.hpp>
#include <imgui.h>

const int vs_ocornut_imgui_len = 480;
const unsigned char vs_ocornut_imgui[] = {
    0x56,0x53,0x48,0x06,0x00,0x00,0x00,0x00,0x01,0x83,0xF2,0xE1,0x01,0x00,0x0B,0x75,0x5F,0x76,0x69,0x65,0x77,0x54,0x65,0x78,0x65,
    0x6C,0x02,0x01,0x00,0x00,0x01,0x00,0xBA,0x01,0x00,0x00,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x20,0x76,0x65,0x63,0x34,
    0x20,0x61,0x5F,0x63,0x6F,0x6C,0x6F,0x72,0x30,0x3B,0x0A,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x20,0x76,0x65,0x63,0x33,
    0x20,0x61,0x5F,0x70,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x3B,0x0A,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x20,0x76,0x65,
    0x63,0x32,0x20,0x61,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,0x64,0x30,0x3B,0x0A,0x76,0x61,0x72,0x79,0x69,0x6E,0x67,0x20,0x76,
    0x65,0x63,0x34,0x20,0x76,0x5F,0x63,0x6F,0x6C,0x6F,0x72,0x30,0x3B,0x0A,0x76,0x61,0x72,0x79,0x69,0x6E,0x67,0x20,0x76,0x65,0x63,
    0x32,0x20,0x76,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,0x64,0x30,0x3B,0x0A,0x75,0x6E,0x69,0x66,0x6F,0x72,0x6D,0x20,0x76,0x65,
    0x63,0x34,0x20,0x75,0x5F,0x76,0x69,0x65,0x77,0x54,0x65,0x78,0x65,0x6C,0x3B,0x0A,0x76,0x6F,0x69,0x64,0x20,0x6D,0x61,0x69,0x6E,
    0x20,0x28,0x29,0x0A,0x7B,0x0A,0x20,0x20,0x76,0x65,0x63,0x32,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x31,0x3B,0x0A,0x20,0x20,
    0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x31,0x20,0x3D,0x20,0x28,0x28,0x32,0x2E,0x30,0x20,0x2A,0x20,0x61,0x5F,0x70,0x6F,0x73,0x69,
    0x74,0x69,0x6F,0x6E,0x2E,0x78,0x79,0x29,0x20,0x2A,0x20,0x75,0x5F,0x76,0x69,0x65,0x77,0x54,0x65,0x78,0x65,0x6C,0x2E,0x78,0x79,
    0x29,0x3B,0x0A,0x20,0x20,0x76,0x65,0x63,0x34,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x32,0x3B,0x0A,0x20,0x20,0x74,0x6D,0x70,
    0x76,0x61,0x72,0x5F,0x32,0x2E,0x7A,0x77,0x20,0x3D,0x20,0x76,0x65,0x63,0x32,0x28,0x30,0x2E,0x30,0x2C,0x20,0x31,0x2E,0x30,0x29,
    0x3B,0x0A,0x20,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x32,0x2E,0x78,0x20,0x3D,0x20,0x28,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,
    0x31,0x2E,0x78,0x20,0x2D,0x20,0x31,0x2E,0x30,0x29,0x3B,0x0A,0x20,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x32,0x2E,0x79,0x20,
    0x3D,0x20,0x28,0x31,0x2E,0x30,0x20,0x2D,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x31,0x2E,0x79,0x29,0x3B,0x0A,0x20,0x20,0x67,
    0x6C,0x5F,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x20,0x3D,0x20,0x74,0x6D,0x70,0x76,0x61,0x72,0x5F,0x32,0x3B,0x0A,0x20,0x20,
    0x76,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,0x64,0x30,0x20,0x3D,0x20,0x61,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,0x64,0x30,
    0x3B,0x0A,0x20,0x20,0x76,0x5F,0x63,0x6F,0x6C,0x6F,0x72,0x30,0x20,0x3D,0x20,0x61,0x5F,0x63,0x6F,0x6C,0x6F,0x72,0x30,0x3B,0x0A,
    0x7D,0x0A,0x0A,0x00,0x00
};

const int fs_ocornut_imgui_len = 186;
const unsigned char fs_ocornut_imgui[] = {
    0x46,0x53,0x48,0x06,0x01,0x83,0xF2,0xE1,0x00,0x00,0x00,0x00,0x01,0x00,0x05,0x73,0x5F,0x74,0x65,0x78,0x00,0x01,0x00,0x00,0x01,
    0x00,0x9A,0x00,0x00,0x00,0x76,0x61,0x72,0x79,0x69,0x6E,0x67,0x20,0x76,0x65,0x63,0x34,0x20,0x76,0x5F,0x63,0x6F,0x6C,0x6F,0x72,
    0x30,0x3B,0x0A,0x76,0x61,0x72,0x79,0x69,0x6E,0x67,0x20,0x76,0x65,0x63,0x32,0x20,0x76,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,
    0x64,0x30,0x3B,0x0A,0x75,0x6E,0x69,0x66,0x6F,0x72,0x6D,0x20,0x73,0x61,0x6D,0x70,0x6C,0x65,0x72,0x32,0x44,0x20,0x73,0x5F,0x74,
    0x65,0x78,0x3B,0x0A,0x76,0x6F,0x69,0x64,0x20,0x6D,0x61,0x69,0x6E,0x20,0x28,0x29,0x0A,0x7B,0x0A,0x20,0x20,0x67,0x6C,0x5F,0x46,
    0x72,0x61,0x67,0x43,0x6F,0x6C,0x6F,0x72,0x20,0x3D,0x20,0x28,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x44,0x20,0x28,0x73,0x5F,
    0x74,0x65,0x78,0x2C,0x20,0x76,0x5F,0x74,0x65,0x78,0x63,0x6F,0x6F,0x72,0x64,0x30,0x29,0x20,0x2A,0x20,0x76,0x5F,0x63,0x6F,0x6C,
    0x6F,0x72,0x30,0x29,0x3B,0x0A,0x7D,0x0A,0x0A,0x00,0x00
};

bgfx::VertexLayout imgui_vertex_layout; 
bgfx::TextureHandle imgui_font_texture;
bgfx::UniformHandle imgui_font_uniform;
bgfx::ProgramHandle imgui_program;
void imgui_render(ImDrawData *data);
GLFWwindow *imgui_window = NULL;
GLFWcursor *mouse_cursors[ImGuiMouseCursor_COUNT] = { 0 };

void imgui_init(GLFWwindow *window) {
    imgui_window = window;

    unsigned char *data; 
    int width = 0; 
    int height = 0; 
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();

    imgui_vertex_layout
        .begin()
        .add(bgfx::Attrib::Position, 2, bgfx::AttribType::Float)
        .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float)
        .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
        .end();

    io.Fonts->AddFontDefault();
    io.Fonts->GetTexDataAsRGBA32(&data, &width, &height);

    imgui_font_texture = bgfx::createTexture2D(width, height, false, 1, bgfx::TextureFormat::BGRA8, 0, bgfx::copy(data, width*height*4));
    imgui_font_uniform = bgfx::createUniform("s_tex", bgfx::UniformType::Sampler);


    bgfx::ShaderHandle vs = bgfx::createShader(bgfx::makeRef(vs_ocornut_imgui, vs_ocornut_imgui_len));
    bgfx::ShaderHandle fs = bgfx::createShader(bgfx::makeRef(fs_ocornut_imgui, fs_ocornut_imgui_len));
    imgui_program = bgfx::createProgram(vs, fs, true);

    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;

    io.SetClipboardTextFn = imgui_set_clipboard_text;
    io.GetClipboardTextFn = imgui_get_clipboard_text;
    io.ClipboardUserData = window;

    mouse_cursors[ImGuiMouseCursor_Arrow] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    mouse_cursors[ImGuiMouseCursor_TextInput] = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);
    mouse_cursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    mouse_cursors[ImGuiMouseCursor_ResizeNS] = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);
    mouse_cursors[ImGuiMouseCursor_ResizeEW] = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);
    mouse_cursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    mouse_cursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    mouse_cursors[ImGuiMouseCursor_Hand] = glfwCreateStandardCursor(GLFW_HAND_CURSOR);
}

void imgui_render(ImDrawData *draw_data) {
    for (int i = 0; i  < draw_data->CmdListsCount; ++i) {
        bgfx::TransientVertexBuffer tvb;
        bgfx::TransientIndexBuffer tib;

        const ImDrawList *draw_list = draw_data->CmdLists[i];
        unsigned int num_vertices = (unsigned int) draw_list->VtxBuffer.size();
        unsigned int num_indices = (unsigned int) draw_list->IdxBuffer.size();

        if (!bgfx::getAvailTransientVertexBuffer(num_vertices, imgui_vertex_layout) ||
                !bgfx::getAvailTransientIndexBuffer(num_indices)) {
            break;
        }

        bgfx::allocTransientVertexBuffer(&tvb, num_vertices, imgui_vertex_layout);
        bgfx::allocTransientIndexBuffer(&tib, num_indices);

        ImDrawVert *verts = (ImDrawVert *) tvb.data;
        memcpy(verts, draw_list->VtxBuffer.begin(), num_vertices * sizeof(ImDrawVert));

        ImDrawIdx *indices = (ImDrawIdx *) tib.data;
        memcpy(indices, draw_list->IdxBuffer.begin(), num_indices * sizeof(ImDrawIdx));

        unsigned int offset = 0; 
        for (const ImDrawCmd *cmd = draw_list->CmdBuffer.begin(), *cmd_end = draw_list->CmdBuffer.end(); cmd != cmd_end; ++cmd) {
            if (cmd->UserCallback) {
                cmd->UserCallback(draw_list, cmd);
            }
            else if (cmd->ElemCount != 0) {
                unsigned long state = BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A | BGFX_STATE_MSAA;
                bgfx::TextureHandle th = imgui_font_texture;
                if (((unsigned int *) cmd->TextureId) != NULL) {
                    th.idx = (unsigned short) *((unsigned int *) cmd->TextureId);
                }

                state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
                const unsigned short xx = (unsigned short) bx::max(cmd->ClipRect.x, 0.0f);
                const unsigned short yy = (unsigned short) bx::max(cmd->ClipRect.y, 0.0f);
                bgfx::setScissor(xx, yy, (unsigned short) bx::min(cmd->ClipRect.z, 65535.0f)-xx, (unsigned short) bx::min(cmd->ClipRect.w, 65535.0f)-yy);
                bgfx::setState(state);
                bgfx::setTexture(0, imgui_font_uniform, th);
                bgfx::setVertexBuffer(0, &tvb, 0, num_vertices);
                bgfx::setIndexBuffer(&tib, offset, cmd->ElemCount);
                bgfx::submit(200, imgui_program);
            }

            offset += cmd->ElemCount;
        }

    }
}

void imgui_reset(int width, int height) {
    bgfx::setViewRect(200, 0, 0, width, height);
}

void imgui_events(float dt) {
    ImGuiIO &io = ImGui::GetIO();

    int w = 0; 
    int h = 0; 
    int display_w = 0; 
    int display_h = 0; 
    glfwGetWindowSize(imgui_window, &w, &h);
    glfwGetFramebufferSize(imgui_window, &display_w, &display_h);
    io.DisplaySize = ImVec2((float)w, (float)h);
    io.DisplayFramebufferScale = ImVec2(w > 0 ? ((float) display_w/w) : 0, h > 0 ? ((float) display_h/h) : 0);

    io.DeltaTime = dt;

    const ImVec2 mouse_pos_backup = io.MousePos;
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);

    const bool focused = glfwGetWindowAttrib(imgui_window, GLFW_FOCUSED) != 0;
    if (focused) {
        if (io.WantSetMousePos) {
            glfwSetCursorPos(imgui_window, (double) mouse_pos_backup.x, (double) mouse_pos_backup.y);
        } else {
            double mouse_x = 0; 
            double mouse_y = 0; 
            glfwGetCursorPos(imgui_window, &mouse_x, &mouse_y);
            io.MousePos = ImVec2((float) mouse_x, (float) mouse_y);
        }
    }

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    glfwSetCursor(imgui_window, mouse_cursors[imgui_cursor] ? mouse_cursors[imgui_cursor] : mouse_cursors[ImGuiMouseCursor_Arrow]);
    glfwSetInputMode(imgui_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
}

void imgui_shutdown(void) {
    bgfx::destroy(imgui_font_uniform);
    bgfx::destroy(imgui_font_texture);
    bgfx::destroy(imgui_program);
    ImGui::DestroyContext();
}

const char *imgui_get_clipboard_text(void *user_data) {
    return glfwGetClipboardString((GLFWwindow *) user_data);
}

void imgui_set_clipboard_text(void *user_data, const char *text) {
    glfwSetClipboardString((GLFWwindow *) user_data, text);
}

